I. Data Cleaning & Wrangling 
  In the initial loading of the new score dataset, I read in the file by indexing the data frame according to student identification, a numerical value. Before performing any processing on the grades, any students that did not take the final exam must be removed from the data frame. To identify those students, the isna() and sum() functions are utilized to determine the number of students who are missing the final exam. In order to remove these students from the dataframe, I utilized the pandas loc() function in combination with the isna() function and the ‘~’ identifier to exclude any rows where the final exam was a null value. Once those students were removed, data aggregation and processing could be performed.
II. Data Aggregation
  a. Quiz Averaging
	  The first step in processing the student performance data for grade and GPA determination is to aggregate the students' quizzes and determine the average quiz grade for each individual student. I used the dictionary mapping process and created a data frame of quizzes to aggregate into the quiz average. 
The grading criteria stipulates that the lowest two quiz scores must be dropped before taking the quiz average from the aggregated data. To achieve this, I utilized the .iloc() applied to the quiz data frame to access every row. I then utilized the apply() function  in combination with lambda and NumPy arrays to calculate the average of each student's quiz. Inside the apply function, a lambda formula is defined to iterate by row where each row in the quiz data frame represents a single student’s performance. Each row is then treated as a NumPy array that is sorted in ascending order. The average of the quiz scores in the array is then taken starting from the index of 2 which would be the third lowest score as stipulated in the grading requirements.
  b. Midterm
    i. Regression Analysis
	  As previously conducted, the only other null value in the data frame is in the ‘midterm_1’ column. To determine the index position of this null value, I utilized the loc() method and the isna() function.
	Grading criteria requires that the predicted value from the regression of the quiz average against the specific midterm can replace a missing midterm score for those students who have taken the final exam. In order to replace the null value of “midterm_1” for students [8996487694], I first ran regression analysis on the specified attributes of the data frame. I created two separate data frames of the quiz averages and the midterm 1 grades identified by student ID values to be used in merging the data frames. Upon reflection, this merger was wholly unnecessary as a single data frame could have been created and used instead of creating and merging two data frames. 
	I then separated the data frame into two datasets, a training dataset and a test dataset. The training dataset consisted of every instance/student that did not have a null-value for midterm 1 while the test dataset consisted of the student who missed midterm 1.
	Once the datasets were separated, I utilized the scikit-learn Linear Regression function to create a regression model instance. I identified the quiz averages as the x-values  and the midterm 1 grades as the y-values in the training dataset. With the x- and y- values identified, I fit the training dataset to the regression model instance. Using the coef_ and intercept_ methods the model produced was the following:
$y = 5.73455459(Quiz_Avg) + 30.53118193033194$
    ii. Predicting Midterm Values
	Once the regression model was run on the training data and a model was produced, I could then utilize the test data’s quiz average value to predict a midterm 1 value. The scikit-learn Linear Regression includes the predict() function that takes the defined x-value as an argument and applies it to the model. Once the value for the missing midterm one was predicted, I retrieved the student ID index previously identified and replaced the null value with the predicted value.
Calculating Midterm Averages
	With no null midterm scores, I utilized the dictionary mapping process once more to create a midterm data frame indexed by student. I defined a midterm averaging function to calculate the weight of each midterm by score. In my function, I made each row of the midterm data frame into a NumPy array which held each of the three midterm scores for a single student. I then sorted the midterms and applied a 20% weight to the zero-index or lowest midterm score, 35% weight to the one-index, and 45% weight to the two-index or highest score and returned their sum as the midterm average.
  c. Course Grade
To determine the course grade as indicated by the grading criteria, I defined a function which took the aggregate data frame rows and set their attribute values in a corresponding NumPy array. I initially added Final exam scores to the aggregate data frame first, then quiz average, then midterm average, as such my indexes were as follows: final exam at index zero, quiz average at index 1, and midterm average at index 2. I calculated students’ weighted course grades in correspondence with these indexes with quiz average at 15%, midterm average at 45%, and final exam at 40%.

III.  Letter Grade Determination
  a. Exploratory Data Analysis
	I utilized the MatPlot Library to create a two-by-two display of four subplots. In each plot I then utilized the seaborn library to generate density histograms of each exam grade or average and course grade with 12 bins to represent the 12 letter grades.
  b. Bin-Sizing
	Upon observing the structure of the score data in histogram plots, I decided to use the NumPy arange() function to create same-sized arrays that would function as bins to separate the score data for each attribute. Since there are 12 available letter grades, I identified the starting value of the array to be zero and the step value to be 1 + 1/12  1/12. This generated 12 bins that could be assigned to each of the 12 letter grades or regular GPAvalues. Since there are 13 rather than 12 weighted GPA values, the step was changed 1/13ths instead of 1/12ths to account for each value. I then Identified the lists of GPA, weighted GPA, and letter grade values.
	With bin sizes determined, I could apply the Pandas cut() function to the aggregate data frame to assign GPA and letter grade values to appropriate exam and course grades. The bins arguments correspond to the respective quantile arrays calculated with the aforementioned NumPy arange() function. The list of letters and GPA values are indicated as labels for corresponding bins in the data frame according to grading criteria.

IV. Final Score Data
	Once every score for each student was assigned a GPA or letter grade, I used the Pandas DataFrame() function to create a final data frame with the assigned grade values and letters corresponding to each individual student determined by the cut() function. 
	The grading criteria requires student scores to be sorted by Course Weighted GPA in descending order beginning with 4.00. To achieve this, I utilized the loc method to ensure an entire row was being sorted with its corresponding attributes rather than sorting a single attribute column. I then applied the sort_values() function to sort rows by the ‘Course_Weighted_GPA’ attribute and indicated descending order by setting ascending equal to False. To visualize the results of this sorting, I applied the head method with an argument of 10 to display the first ten rows.

V. Review
	In review, there are ways in which I could have consolidated this process. I could have minimized my use of data frame creation and expanded on my implementation of function definition and use of NumPy arrays. However, the speed at which the code operates is notable. It is particularly notable that the use of loops was unnecessary, allowing for increased efficiency.  
